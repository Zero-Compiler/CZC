# CZC 项目质量评估（2025-11-12）

## 总览

- 代码按照词法分析→预处理→语法分析→格式化→CLI 管线拆分，模块划分清晰并配有详细文档注释。
- 提供了国际化诊断系统（`locales/*/diagnostics.toml`）与 SourceTracker，用于高质量的错误定位。
- 测试目录覆盖 lexer、parser、formatter 等核心组件，但总体仍以手写 `assert` 驱动为主，缺乏自动化保障。

## 高优先级问题

1. **语法解析在缺失分隔符时会立即崩溃**：`Parser::fn_declaration` 在 `consume(TokenType::LeftParen)` 返回 `std::nullopt` 时仍解引用 `*left_paren`（`src/parser/parser.cpp:296-305`），`block_statement` 也有相同模式（`src/parser/parser.cpp:534-545`）。一旦源文件缺失对应括号，解析期望的错误恢复逻辑无法执行，程序直接触发 UB/崩溃。
2. **赋值表达式缺乏空指针防护**：`Parser::assignment` 假定 `logical_or()` 一定返回节点，在 `match_token('=')` 后立刻访问 `expr->get_type()`（`src/parser/parser.cpp:621-655`）。语法错误导致 `expr==nullptr` 时会立即崩溃，无法向用户报告诊断。
3. **科学计数法整型溢出从未发出诊断**：虽然定义了 `DiagnosticCode::T0001_ScientificIntOverflow`，`ScientificNotationAnalyzer::fits_in_int64`/`infer_type` 只是在溢出时退化为 `FLOAT`，没有调用任何 `report_error`（`src/token_preprocessor/token_preprocessor.cpp:125-177`）。这会让开发者在整数溢出时得不到任何提示，也与本地化文案不符。
4. **Formatter 大量节点仍为 TODO，输出不可控**：`visit_if_stmt`、`visit_while_stmt`、`visit_index_expr`、`visit_member_expr`、`visit_assign_expr`、`visit_array_literal`、`visit_paren_expr`、`visit_type_annotation`、`visit_array_type`、`visit_parameter`、`visit_argument_list` 等均只是简单拼接子节点（`src/formatter/formatter.cpp:197-335, 402-447`）。这意味着含 if/while/数组/调用的源码会在格式化后丢失缩进、空格甚至关键字结构，`FormatOptions` 中的大部分选项（例如 `space_before_paren`、`space_after_comma`、`newline_before_brace`）也完全未被使用。
5. **CLI 诊断提取存在 O(n·errors) 的重复扫描**：`tokenize_file` 在收集每条词法或预处理错误时都重新构造 `SourceTracker` 并扫描整份源码获取行文本（`cli/main.cpp:170-205`）。大型文件上一旦出现多条错误会呈线性乘法级别的性能退化，而 `parse_file` 已经证明可以复用单个 `SourceTracker`（`cli/main.cpp:245-314`）。

## 构建与测试风险

1. **测试 CMake 配置无法在受限网络或自定义 main 的场景下构建**：`tests/CMakeLists.txt` 通过 `FetchContent` 强制在线拉取 googletest（`tests/CMakeLists.txt:3-13`），与当前受限网络策略冲突；同时所有 test 目标都链接 `gtest_main`（`tests/CMakeLists.txt:21-75`）但大多数测试文件自带 `main()`（如 `tests/test_lexer.cpp:409-435`、`tests/test_parser.cpp:290-315` 等），会导致重复定义 `main` 的链接错误。
2. **`test_source_tracker_performance` 占用超大内存/时间**：该测试一次性生成 1000 万行源码（约数百 MB）再遍历（`tests/test_source_tracker_performance.cpp:30-80`），根本不适合作为常规 CI 测试，容易在一般机器上 OOM。
3. **大量测试依赖 `assert`**：例如 `tests/test_parser.cpp`、`tests/test_lexer.cpp`、`tests/test_token_preprocessor.cpp` 等都依赖 `<cassert>`，Release 构建会直接跳过断言，无法捕获回归。
4. **安装脚本安装头文件必然失败**：顶层 `CMakeLists.txt` 安装 `include/czc`（`CMakeLists.txt:54-56`），但仓库并不存在 `include/` 目录，执行 `cmake --install` 会直接报错。
5. **测试缺失区块注释、格式化行为、国际化切换等关键场景**：现有测试几乎全是 happy-path 示例，未覆盖 lexer 未实现的 `/* ... */` 注释、Formatter 的 TODO 节点，以及 i18n 诊断加载失败路径。

## 其他观察

- CLI/库层次设计良好，`SourceTracker` 的惰性行缓存与 `Utf8Handler` 的 UTF-8 处理为后续语言特性提供了基础（`src/utils/source_tracker.cpp`, `src/lexer/utf8_handler.cpp`）。
- 诊断系统支持本地化 fallback（`src/diagnostics/diagnostic.cpp:21-88`），并能格式化消息；这是项目的亮点之一。
- `FileCollector` 提供了简单的通配符展开和排序（`src/utils/file_collector.cpp:16-128`），便于 CLI 批量处理文件。
- `TokenPreprocessor` 将科学计数法拆分为分析对象并在 CLI 中串联使用，形成了较清晰的前端 pipeline。

## 建议（按优先级）

1. 修复 parser 对缺失分隔符/表达式的空指针解引用，确保所有 `consume()` 失败路径都能安全落地并插入占位 token。
2. 在 `ScientificNotationAnalyzer::fits_in_int64` 或其调用链上真正触发 `T0001` 诊断，保持与本地化文案一致，并补充针对 INT/FLOAT 溢出的单元测试。
3. 实质性实现 Formatter 中所有 TODO，并让 `FormatOptions` 的字段真正影响输出；缺失实现前应在 CLI 中禁用或标记实验性状态。
4. 调整 CLI 诊断收集逻辑，重用单个 `SourceTracker`/缓存的源码行，避免每条错误重新扫描全文。
5. 重构测试构建脚本：
   - 允许运行在无网络环境（预置 gtest 或改用现有手写 main）
   - 只对真正使用 GoogleTest 的目标链接 `gtest_main`
   - 将大数据量性能验证迁移到 `benchmarks/` 或按需开启
   - 替换 `assert` 为测试框架断言，以便 Release 构建同样有效。
6. 在 CMake 安装阶段复制真实存在的头文件目录（例如 `czc/`），或调整 include 结构到标准的 `include/czc`。
