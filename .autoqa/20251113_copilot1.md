# Zero 语言 struct / array 类型设计评估（2025-11-13）

## 结论速览

- 当前实现聚焦在语法前端，`czc/parser/parser.cpp` 和 `src/parser/parser.cpp` 负责构造保留所有词法信息的 CST，尚未进入 AST 与语义分析阶段。
- 语言层面已经提供 `struct`、动态数组 `T[]`、定长数组 `T[N]`、匿名结构体、元组与函数签名类型等构造，测试覆盖集中在 `tests/test_struct_type_alias.cpp` 与 `tests/test_array_types.cpp`。
- 类型表达式语义缺位：`src/ast` 目录为空，缺乏类型检查、布局推导与运行时模型定义，导致语言设计与实现脱节。
- 数组与结构体语法与多语言接近，但行为规格未明确，易在未来实现阶段引入歧义与 breaking change。

## 已实现能力梳理

### Struct 声明与字面量

- `Parser::struct_declaration`（`src/parser/parser.cpp` 460-619）解析 `struct Name { field: Type } ;`，允许尾逗号并检测重复字段名（线性扫描 `field_names`）。
- 字段类型通过 `parse_type_expression` 支持数组、元组、联合、交集等复合类型，说明设计目标面向静态类型系统。
- 匿名结构体类型 `struct { ... }` 由 `parse_type_primary` 处理，可嵌入类型别名，测试位于 `tests/test_struct_type_alias.cpp` 的 `StructLiteral` 场景。
- 结构体字面量解析和格式化在 `tests/test_struct_type_alias.cpp` 中验证，包括嵌套、消歧（与 `if` 代码块），表明语法前端已考虑常见二义性。

### 数组类型

- `parse_type` 与 `parse_type_primary` 重复实现数组后缀处理，支持动态数组 `T[]` 与定长数组 `T[N]` 的任意多维组合（`Integer[5][]`, `((T)->R)[]`）。
- 数组字面量 `[expr, ...]` 与置于结构体字段、函数参数、返回值的场景在 `tests/test_array_types.cpp` 全面覆盖。
- Formatter 在 `visit_array_type` 与 `visit_sized_array_type`（`src/formatter/formatter.cpp` 669-706）按词法拼接输出，未对空白与括号做语义优化。

### 其他类型构造

- 类型表达式文法支持联合 `|`、交集 `&`、否定 `~`、函数签名 `(T1, T2) -> (R1, R2)` 以及元组类型 `(T1, T2)`，对应实现分布在 `parse_type_union`、`parse_type_intersection`、`parse_type_primary`。
- 这些特性在 `tests/test_struct_type_alias.cpp` 与类型别名测试中有字符串级断言，显示语言定位于具备高级类型组合能力的静态语言。
- `TokenPreprocessor`（`src/token_preprocessor/token_preprocessor.cpp`）对科学计数类型做推断，但尚未结合结构体与数组，说明数值类型策略仍割裂。

## 与主流语言对比

### Rust

- Zero 的 `struct` 语法与 Rust 相近，但缺少 `impl`、可见性与生命周期检查；Rust 的 `[T; N]` 与 `Vec<T>` 在语义上区分堆栈存储，而 Zero 的 `T[]` / `T[N]` 仅有语法层区分。
- Rust 的匿名结构体缺席，Zero 支持 `struct { ... }` 类型别名，这是更 TypeScript 的风格，需要额外语义定义。

### Python

- Python 以动态列表和字典为核心，`typing` 的 `List[T]`、`TypedDict` 仅为静态提示；Zero 虽提供静态类型组合，却未对应运行时行为，当前程度介于 Python typing 与实际编译型语言之间。
- Python 的结构化类型多依赖 `dataclasses`/`pydantic`，Zero 的编译式 `struct` 是优势，但必须定义默认值、可选字段等语义以吸引脚本语言场景。

### Java

- Java 的 `T[]` 是固定长度对象，动态数组交由 `ArrayList<T>`；Zero 将 `T[]` 视作“动态数组”但缺少容量/分配策略说明，可能在未来与 Java 互操作时产生困惑。
- Java 使用 `class` 搭配构造函数与访问控制，Zero 的 `struct` 缺少方法、封装与继承说明，功能更接近 Java 记录类型的未完成版本。

### C++

- C++ 的 `struct`/`class` 区别在默认可见性，Zero 没有可见性语义；C++ 的静态数组 `T[N]` 与 `std::vector<T>` 语义明确，而 Zero 的 `T[]` 语义空缺。
- C++17 起提供 `std::variant`、`std::any` 等类型组合工具，与 Zero 的联合/交集/否定类型目标类似，但 C++ 有成熟的模板与元编程支撑；Zero 缺少泛型说明，难以表达容器与结构体的多态需求。

## 主要问题与风险

- 语义层缺失：`src/ast` 空目录表明尚无 AST 构造与类型检查，实现停留在 CST/Formatter，语言规格无法验证或生成代码。
- 数组语义模糊：虽然语法区分 `T[]` 与 `T[N]`，但缺少内存模型、拷贝/借用策略，未来实现时需要决定是 Go slice、Rust slice 还是 Java 数组的语义。
- 解析器重复逻辑：`parse_type` 与 `parse_type_primary` 中数组后缀逻辑几乎一致，维护成本高且容易产生行为分歧。
- 结构体声明强制分号：`struct Foo {...};` 借鉴 C/C++，与 Rust/TypeScript/Go 常见习惯不符，可能影响语言亲和度。
- 类型组合过于超前：联合/交集/否定类型尚无语义实现，容易在未来语义层引入组合爆炸或不一致的类型等价规则。
- 测试聚焦格式化：多数断言以字符串包含判断结果，缺乏结构化验证，无法捕获语义层缺陷。
- 字段重复检查为 O(n²)：`std::find` 每次线性扫描 `field_names`，在大型结构体声明下会产生不必要的性能损耗。

## 改进建议

- 尽快补全 AST 与类型检查框架，明确 `struct`、数组、联合类型的内存与语义规则，避免语法与实现脱节。
- 抽取数组后缀解析为独立函数，供 `parse_type`、`parse_type_primary`、函数签名分支复用，降低维护风险。
- 在设计文档中明确 `T[]` 的具体语义（动态长度、底层容器、可变性），并在后续实现中与运行时/标准库保持一致。
- 考虑允许省略结构体声明末尾分号或提供可配置语法，以贴近现代语言习惯。
- 为类型组合设计规范（等价、简化、空集处理），并在测试中引入针对性案例，避免日后实现时产生不可实现的规范。
- 增强测试：使用 CST 结构断言或引入初步语义测试，减少对格式化字符串的依赖。
- 针对大结构体优化重复字段检测，可改用 `std::unordered_set` 或排序去重。

## 复盘

本次评估主要基于 `src/parser/parser.cpp`、`src/formatter/formatter.cpp` 与 `tests` 目录的实现与断言，目标是理解 Zero 语言现有的结构化类型设计。阅读过程中发现语言设计明显超前于实现状态：语法层面已经引入 TypeScript 式组合类型，但缺乏后端支撑。下一轮应关注 AST 与类型检查模块的规划，以及数组/结构体的运行时语义草案，以确保设计能够落地。
